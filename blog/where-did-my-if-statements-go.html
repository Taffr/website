<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="stylesheet" href="/styles.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Where did my if-statements go?: Simon Tenggren.xyz</title>
  </head>
  <body>
    <div id="nav-elm"></div>
    <script type="module">
      import { Elm } from '../src/Elements/Nav.elm'
      Elm.Elements.Nav.init({ node: document.getElementById('nav-elm'), flags: "blog" })
    </script>
    <div class="page-wrapper">
      <div class="page-body-wrapper">
        <div class="blog-body">
          <div class="blog-title-stack">
            <h1 class="blog-title"> Where did my if-statements go? </h1>
            <div class="ui-separator-horizontal" style="width: 10%;"></div>
            <h2 class="blog-sub-title"> Safer and readable TypeScript</h2>
          </div>
          <div class="ui-separator-horizontal"></div>
          <h3 class="blog-sub-heading">Introduction</h3>
          Take a look at the following bit of TypeScript code:
          <pre class="code-block">
<span class="token keyword">async function</span> <span class="token function">getData</span>(): <span class="token type">Promise&lt;Data&gt;</span> {
  <span class="token keyword">const</span> response = <span class="token keyword">await</span> fetch(<span class="token string">'https://api.example.com/foo'</span>);
  <span class="token keyword">const</span> json = <span class="token keyword">await</span> response.<span class="token function">json</span>();
  <span class="token keyword">return</span> dataSchema.<span class="token function">parse</span>(json);
}
          </pre>
          Can you see what is wrong with it?
          <br><br>
          Any of the lines can throw an exception. TypeScript provides no help here — we’re forced to rely on try/catch blocks, and there's no declaration of what kind of errors a function might throw. Even if it would, how are we supposed to handle the error if it fails? Does the caller know if this function handles the error or not? There are several deep pits here, and without paying very special attention it is easy to fail into one of them.

          <h3 class="blog-sub-heading"> How do other languages deal with the problem? </h3>
          Some languages, such as Java, force you to declare that the methods throw an exception or catch it yourself right away, this makes it more or less obvious for the caller if the error was properly handled or not. A language such as Go is a more interesting example, instead of throwing exceptions errors and results are returned in a tuple-like structure which when combined with a check for un-used variables forces the caller to handle the error.
          <br><br>
          The "problem" with this is that it requires a bunch of branches to be created to check that the error is <code>nil</code>.
          Resulting in code that looks something like the following:
          <pre class="code-block">
<span class="token function">result1</span>, <span class="token function">err</span> := <span class="token function">doSomething</span>()
<span class="token keyword">if</span> <span class="token function">err</span> != <span class="token constant">nil</span> {
    <span class="token keyword">return</span> <span class="token function">handleErr</span>(<span class="token function">err</span>) 
}

<span class="token function">result2</span>, <span class="token function">err</span> := <span class="token function">doAnotherThing</span>(<span class="token function">result1</span>)
<span class="token keyword">if</span> <span class="token function">err</span> != <span class="token constant">nil</span> {
    <span class="token keyword">return</span> <span class="token function">handleErr</span>(<span class="token function">err</span>) 
}

<span class="token function">result3</span>, <span class="token function">err</span> := <span class="token function">doYetAnotherThing</span>(<span class="token function">result2</span>)
<span class="token keyword">if</span> <span class="token function">err</span> != <span class="token constant">nil</span> {
    <span class="token keyword">return</span> <span class="token function">handleErr</span>(<span class="token function">err</span>) 
}
          </pre>
          This is nice and definitely a great improvement, but to me <sup><a href="#not-a-go-dev">1</a></sup> this is way to repetetive and makes have to think of the less important part, when what I really want to focus on is the successful case and keep the code as readable and "on track" as possible without distracting control flow to constantly handle the case where something goes wrong.
          <h3 class="blog-sub-heading"> The alternative </h3>
          Let's rewrite the above example, but in TypeScript (however probably any typed language will do), we instead use something called the <code>Result</code> type/pattern paired with the <code>andThen</code> utility function. 
<pre class="code-block">
<span class="token keyword">const</span> result1 = <span class="token function">doSomething</span>()
<span class="token keyword">const</span> result2 = <span class="token function">Result.andThen</span>(doAnotherThing, result1)
<span class="token keyword">const</span> result3 = <span class="token function">Result.andThen</span>(doYetAnotherThing, result2)
</pre>
          The code now looks more streamlined, <b>but where did my if-statements go?</b> I can tell you that they are securely baked into the <code>Result</code> and we are just as safe, if not safer, than before. Why is it safer? Lets have a look at the implementation.

<pre class="code-block">
<span class="token keyword">type</span> <span class="token class-name">Ok</span>&lt;T&gt; = { <span class="token property">type</span>: <span class="token string">'ok'</span>; <span class="token property">value</span>: T };
<span class="token keyword">type</span> <span class="token class-name">Err</span>&lt;E&gt; = { <span class="token property">type</span>: <span class="token string">'err'</span>; <span class="token property">error</span>: E };

<span class="token keyword">type</span> <span class="token class-name">Result</span>&lt;T, E&gt; = Ok&lt;T&gt; | Err&lt;E&gt;;

<span class="token keyword">function</span> <span class="token function">ok</span>&lt;T&gt;(value: T): Ok&lt;T&gt; {
  <span class="token keyword">return</span> { type: <span class="token string">'ok'</span>, value };
}

<span class="token keyword">function</span> <span class="token function">err</span>&lt;E&gt;(error: E): Err&lt;E&gt; {
  <span class="token keyword">return</span> { type: <span class="token string">'err'</span>, error };
}

<span class="token keyword">function</span> <span class="token function">isOk</span>&lt;T, E&gt;(result: Result&lt;T, E&gt;): result <span class="token keyword">is</span> Ok&lt;T&gt; {
  <span class="token keyword">return</span> result.type === <span class="token string">'ok'</span>;
}

<span class="token keyword">function</span> <span class="token function">isErr</span>&lt;T, E&gt;(result: Result&lt;T, E&gt;): result <span class="token keyword">is</span> Err&lt;E&gt; {
  <span class="token keyword">return</span> result.type === <span class="token string">'err'</span>;
}

<span class="token keyword">function</span> <span class="token function">andThen</span>&lt;T, E, U&gt;(
  fn: (value: T) =&gt; Result&lt;U, E&gt;,
  result: Result&lt;T, E&gt;
): Result&lt;U, E&gt; {
  <span class="token keyword">return</span> isOk(result) ? fn(result.value) : result;
}
</pre>
          <p> Now it is evident where the if-statements went, but we also have the added benefit of not having to think of control flow at all, when we have an error in our code, and we wish to continue we now no longer have to take into account if the action failed, we can continue to move forward. If it was the case that we did fail somewhere, we can carry that error along, and only handle it at last moment, by chaining together calls of <code>andThen</code>-calls.</p>
          <h3 class="blog-sub-heading"> But I can't return a Result from my server! <sub>(or render it on the screen for that matter)</sub></h3>
          This is true - at some point, we must "unwrap" the result and do something based on the outcome, for example in an Express API handler:
<pre class="code-block">
<span class="token function">app.get</span>(<span class="token string">'/data'</span>, <span class="token keyword">async</span> (req, res) =&gt; {
  <span class="token keyword">const</span> result = <span class="token keyword">await</span> <span class="token function">getData</span>();

  <span class="token keyword">const</span> { statusCode, body, isJson } = <span class="token function">unpack</span>(
    (err) =&gt; ({
      statusCode: err.type === <span class="token string">'upstream'</span> ? <span class="token number">503</span> : <span class="token number">500</span>,
      body: err.message,
      isJson: <span class="token boolean">false</span>
    }),
    (data) =&gt; ({
      statusCode: <span class="token number">200</span>,
      body: data,
      isJson: <span class="token boolean">true</span>
    }),
    result
  );

  res.<span class="token function">status</span>(statusCode)[isJson ? <span class="token string">'json'</span> : <span class="token string">'send'</span>](body);
});
</pre>
          <p> The implementation is quite simple, but the important part is that we get functions that return the same type, independent if we had an error during one of our actions, or if all of them were successful. </p>
<pre class="code-block">
<span class="token keyword">function</span> <span class="token function">unpack</span>&lt;E, T, R&gt;(
  <span class="token parameter">onErr: (e: E) =&gt; R,</span>
  <span class="token parameter">onOk: (t: T) =&gt; R,</span>
  <span class="token parameter">result: Result&lt;T, E&gt;</span>
): R {
  <span class="token keyword">if</span> (<span class="token function">isOk</span>(result)) {
    <span class="token keyword">return</span> <span class="token function">onOk</span>(result.value);
  } <span class="token keyword">else</span> {
    <span class="token keyword">return</span> <span class="token function">onErr</span>(result.error);
  }
}
</pre>
          <p>
          In this example, <code>getData</code> returns a <code>Result&lt;Data, DataFetchingError&gt;</code>. Both <code>fetch</code> and <code>response.json()</code> return <code>Result</code> rather than throwing. We can use <code>Result.andThen</code> to chain our logic together while preserving and propagating errors cleanly. <code>unpack</code> is used to convert the result into a concrete action such as an HTTP response.
          </p>

          <h3 class="blog-sub-heading"> Putting it all together </h3>
          Let's rewrite the <code>getData</code> function so that it returns a <code>Promise&lt;Result&lt;Data, DataFetchingError&gt;&gt;</code> instead.
<pre class="code-block">
<span class="token keyword">function</span> <span class="token function">safeParse</span>(<span class="token parameter">json: unknown</span>): <span class="token type">Result&lt;Data, DataFetchingError&gt;</span> {
  <span class="token keyword">try</span> {
    <span class="token keyword">return</span> <span class="token function">ok</span>(dataSchema.<span class="token function">parse</span>(json));
  } <span class="token keyword">catch</span> (e) {
    <span class="token keyword">return</span> <span class="token function">err</span>({
      type: <span class="token string">"parse"</span>,
      message: <span class="token function">String</span>(e)
    });
  }
}

<span class="token keyword">async function</span> <span class="token function">getData</span>(): <span class="token type">Promise&lt;Result&lt;Data, DataFetchingError&gt;&gt;</span> {
  <span class="token keyword">try</span> {
    <span class="token keyword">const</span> res = <span class="token keyword">await</span> fetch(<span class="token string">"https://api.example.com/foo"</span>);
    <span class="token keyword">const</span> json = <span class="token keyword">await</span> res.<span class="token function">json</span>();
    <span class="token keyword">return</span> <span class="token function">safeParse</span>(json);
  } <span class="token keyword">catch</span> (e) {
    <span class="token keyword">return</span> <span class="token function">err</span>({ type: <span class="token string">"upstream"</span>, message: <span class="token function">String</span>(e) });
  }
}
</pre>
          <div class="ui-separator-horizontal"></div>
          <div>
            <aside id="not-a-go-dev">
              <p> <sup>1</sup> I am not a Go developer, however I have heard that one develops "if err != nil" -blindness after a while.</p>
            </aside>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>

