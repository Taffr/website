<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="stylesheet" href="/styles.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Where did my if-statements go?: Simon Tenggren.xyz</title>
  </head>
  <body>
    <div id="nav-elm"></div>
    <script type="module">
      import { Elm } from '../src/Elements/Nav.elm'
      Elm.Elements.Nav.init({ node: document.getElementById('nav-elm'), flags: "blog" })
    </script>
    <div class="page-wrapper">
      <div class="page-body-wrapper">
        <div class="blog-body">
          <div class="blog-title-stack">
            <h1 class="blog-title"> Where did my if-statements go? </h1>
            <div class="ui-separator-horizontal" style="width: 10%;"></div>
            <h2 class="blog-sub-title"> Safer and readable TypeScript</h2>
          </div>
          <div class="ui-separator-horizontal"></div>
          <h3 class="blog-sub-heading">Introduction</h3>
          Take a look at the following bit of TypeScript code:
          <pre class="code-block">
<span class="token keyword">async function</span> <span class="token function">getData</span>(): <span class="token type">Promise&lt;Data&gt;</span> {
  <span class="token keyword">const</span> response = <span class="token keyword">await</span> fetch(<span class="token string">'https://api.example.com/foo'</span>);
  <span class="token keyword">const</span> json = <span class="token keyword">await</span> response.<span class="token function">json</span>();
  <span class="token keyword">return</span> dataSchema.<span class="token function">parse</span>(json);
}
          </pre>
          Can you see what is wrong with it?
          <br><br>
          Any of the lines can throw an exception. TypeScript provides no help here — we’re forced to rely on try/catch blocks, and there's no declaration of what kind of errors a function might throw. Even if it would, how are we supposed to handle the error if it fails? Does the caller know if this function handles the error or not? There are several deep pits here, and without paying very special attention it is easy to fail into one of them.

          <h3 class="blog-sub-heading"> How do other languages deal with the problem? </h3>
          Some languages, such as Java, force you to declare that the methods throw an exception or catch it yourself right away, this makes it more or less obvious for the caller if the error was properly handled or not. A language such as Go is a more interesting example, instead of throwing exceptions errors and results are returned in a tuple-like structure which when combined with a check for un-used variables forces the caller to handle the error.
          <br><br>
          The "problem" with this is that it requires a bunch of branches to be created to check that the error is <code>nil</code>.
          Resulting in code that looks something like the following:
          <pre class="code-block">
<span class="token function">result1</span>, <span class="token function">err</span> := <span class="token function">doSomething</span>()
<span class="token keyword">if</span> <span class="token function">err</span> != <span class="token constant">nil</span> {
    <span class="token keyword">return</span> <span class="token function">handleErr</span>(<span class="token function">err</span>) 
}

<span class="token function">result2</span>, <span class="token function">err</span> := <span class="token function">doAnotherThing</span>(<span class="token function">result1</span>)
<span class="token keyword">if</span> <span class="token function">err</span> != <span class="token constant">nil</span> {
    <span class="token keyword">return</span> <span class="token function">handleErr</span>(<span class="token function">err</span>) 
}

<span class="token function">result3</span>, <span class="token function">err</span> := <span class="token function">doYetAnotherThing</span>(<span class="token function">result2</span>)
<span class="token keyword">if</span> <span class="token function">err</span> != <span class="token constant">nil</span> {
    <span class="token keyword">return</span> <span class="token function">handleErr</span>(<span class="token function">err</span>) 
}
          </pre>
          This is nice and definitely a great improvement, but to me <sup><a href="#not-a-go-dev">1</a></sup> this is way to repetetive and makes have to think of the less important part, when what I really want to focus on is the successful case and keep the code as readable and "on track" as possible without distracting control flow to constantly handle the case where something goes wrong.
          <h3 class="blog-sub-heading"> The alternative </h3>
          Let's rewrite the above example, but in TypeScript (however probably any typed language will do), we instead use something called the <code>Result</code> type/pattern paired with the <code>andThen</code> utility function. 
<pre class="code-block">
<span class="token keyword">const</span> result1 = <span class="token function">doSomething</span>()
<span class="token keyword">const</span> result2 = <span class="token function">Result.andThen</span>(doAnotherThing, result1)
<span class="token keyword">const</span> result3 = <span class="token function">Result.andThen</span>(doYetAnotherThing, result2)
</pre>
          The code now looks more streamlined, <b>but where did my if-statements go?</b> I can tell you that they are securely baked into the <code>Result</code> and we are just as safe (if not safer) than before.



          <h3 class="blog-sub-heading"> But I can't return a Result from my server! </h3>
          This is true — at some point, we must "unwrap" the result and do something based on the outcome, for example in an Express API handler:
          <pre class="code-block">
<span class="token function">app.get</span>(<span class="token string">'/data'</span>, <span class="token keyword">async</span> (req, res) =&gt; {
  <span class="token keyword">const</span> result = <span class="token keyword">await</span> <span class="token function">getData</span>()

  <span class="token function">unpack</span>(
    (err) =&gt; {
      <span class="token keyword">if</span> (err.type === <span class="token string">'upstream'</span>) {
        <span class="token keyword">return</span> res.<span class="token function">status</span>(<span class="token number">503</span>).<span class="token function">send</span>({ error: err.message });
      }
      <span class="token keyword">return</span> res.<span class="token function">status</span>(<span class="token number">500</span>).<span class="token function">send</span>({ error: err.message });
    },
    (data) =&gt; res.<span class="token function">json</span>(data),
    result
  );
});
          </pre>
          <p>
          In this example, <code>getData</code> returns a <code>Result&lt;Data, DataFetchingError&gt;</code>. Both <code>fetch</code> and <code>response.json()</code> return <code>Result</code> rather than throwing. We can use <code>Result.andThen</code> to chain our logic together while preserving and propagating errors cleanly. <code>unpack</code> is used to convert the result into a concrete action such as an HTTP response.
          </p>

          <h3 class="blog-sub-heading"> Putting it all together </h3>
          This simple Result type is powerful and language-agnostic. It encapsulates the control flow of errors while retaining strict type safety. With a couple of functions like <code>ok</code>, <code>err</code>, <code>andThen</code>, and <code>unpack</code>, we can write more predictable and maintainable asynchronous TypeScript code.

          <p>
          Here’s a possible imaginary implementation <sup><a href="#footnote-imaginary-impl">1</a></sup> of <code>getData</code> where each step returns a <code>Result</code>:
          </p>
          <pre class="code-block">
<span class="token keyword">async function</span> <span class="token function">getData</span>(): <span class="token type">Promise&lt;Result&lt;Data, DataFetchingError&gt;&gt;</span> {
  <span class="token keyword">const</span> responseResult = <span class="token keyword">await</span> fetch(<span class="token string">"https://api.example.com/foo"</span>); <span class="token comment">// Result&lt;Response, DataFetchingError&gt;</span>

  <span class="token keyword">const</span> jsonResult = <span class="token function">Result.andThen</span>(
    (res) =&gt; res.<span class="token function">json</span>(),
    responseResult
  );

  <span class="token keyword">return</span> <span class="token function">Result.andThen</span>(
    (json) =&gt; <span class="token function">safeParse</span>(json),
    jsonResult
  );
}
          </pre>

          <p>
          Where <code>safeParse</code> is a utility that returns a <code>Result</code> instead of throwing:
          </p>
          <pre class="code-block">
<span class="token keyword">function</span> <span class="token function">safeParse</span>(<span class="token parameter">json: unknown</span>): <span class="token type">Result&lt;Data, DataFetchingError&gt;</span> {
  <span class="token keyword">try</span> {
    <span class="token keyword">return</span> <span class="token function">ok</span>(dataSchema.<span class="token function">parse</span>(json));
  } <span class="token keyword">catch</span> (e) {
    <span class="token keyword">return</span> <span class="token function">err</span>({ type: <span class="token string">"parse"</span>, message: <span class="token function">String</span>(e) });
  }
}
          </pre>

          <p>
          This final version expresses all failure modes clearly, ensures type safety, and avoids throwing exceptions entirely.
          </p>

          <div class="ui-separator-horizontal"></div>
          <div>
            <aside id="not-a-go-dev">
              <p> <sup>1</sup> I am not a Go developer, however I have heard that one develops "if err != nil" -blindness after a while.</p>
            </aside>
            <aside id="footnote-imaginary-impl">
              <p> <sup>2</sup> Because <code>fetch</code> and <code>.json</code> do not return <code>Promise&lt;Result&lt;...&gt;&gt;</p>
            </aside>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>

